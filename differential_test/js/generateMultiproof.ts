import { StandardMerkleTree } from "@openzeppelin/merkle-tree"
import { decodeAbiParameters, encodeAbiParameters } from 'viem'

// const encodedLeaves = "0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000047000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000ff000000000000000000000000000000000000000000000000000000000000000d00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000fc000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000ff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002700000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000001b00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000025000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000ff00000000000000000000000000000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009f000000000000000000000000000000000000000000000000000000000000002900000000000000000000000000000000000000000000000000000000000000fc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fd000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000004b0000000000000000000000000000000000000000000000000000000000000053000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000027000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000000fe000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000ff000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000ff00000000000000000000000000000000000000000000000000000000000000ff00000000000000000000000000000000000000000000000000000000000000fc0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000fc00000000000000000000000000000000000000000000000000000000000000fd00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000fc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ff000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000e5000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000fc0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000fd000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000fd000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000360000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000002c";
const encodedLeaves = process.argv[2];

// decode the leaves for the merkle tree
const leaves: `0x${string}`[] = decodeAbiParameters(
    [{ name: 'leaves', type: 'bytes32[]' }],
    encodedLeaves as any
)[0].slice().reverse()

// Build the merkle tree. Set the encoding to match the values.
const tree = StandardMerkleTree.of(leaves.map(leaf => [leaf]), ["string"]);

// randomly pick n leaves from the tree to prove
const indicesToProveLength = Math.floor(Math.random() * leaves.length)
let indicesToProve = []
while(indicesToProve.length < indicesToProveLength){
    var r = Math.floor(Math.random() * indicesToProve.length);
    if(indicesToProve.indexOf(r) === -1) indicesToProve.push(r);
}


// generate the proof. Indices to prove need to be in reverse since they are added backwards to the merkle
// tree in the JS implementation
const { proof, proofFlags } = tree.getMultiProof(indicesToProve.map(index => leaves.length - 1 - Number(index)));

// encode the data to send back to forge
const encodedData = encodeAbiParameters(
    [
      { name: 'openZeppelinLeaves', type: 'bytes32[]'},
      { name: 'openZeppelinRoot', type: 'bytes32' },
      { name: 'openZeppelinProof', type: 'bytes32[]' },
      { name: 'openZeppelinFlags', type: 'bool[]' }
    ],
    [
        tree.dump().tree.slice(-leaves.length).reverse() as any,
        tree.root as any, 
        proof as any, 
        proofFlags
    ]
)

// write the proof array and flag array to stdout
process.stdout.write(encodedData)