import { StandardMerkleTree } from "@openzeppelin/merkle-tree"
import { decodeAbiParameters, encodeAbiParameters } from 'viem'
import * as fs from "fs";

const encodedLeaves = "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000074b756d71756174000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005506561636800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054170706c6500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044b6977690000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000054c656d6f6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064f72616e67650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000642616e616e610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000950696e656170706c650000000000000000000000000000000000000000000000";
// const encodedLeaves = process.argv[2];
const encodedIndicesToProve = "0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000007"
// const encodedIndicesToProve = process.argv[3];

const leaves: string[] = decodeAbiParameters(
    [{ name: 'leaves', type: 'string[]' }],
    encodedLeaves as any
)[0].slice().reverse()

const indicesToProve = decodeAbiParameters(
    [{ name: 'indicesToProve', type: 'uint256[]' }],
    encodedIndicesToProve as any
)[0]

// console.log(leaves)
// console.log(indicesToProve)

// Build the merkle tree. Set the encoding to match the values.
const tree = StandardMerkleTree.of(leaves.map(leaf => [leaf]), ["string"]);

// Print the merkle root. You will probably publish this value on chain in a smart contract.
// console.log('Merkle Root:', tree.root);

// generate the proof. Indices to prove need to be in reverse since they are added backwards to the merkle
// tree in the JS implementation
const { proof, proofFlags } = tree.getMultiProof(indicesToProve.map(index => leaves.length - 1 - Number(index)));
// console.log("proof:", proof);
// console.log("proof flags: ", proofFlags);

// encode the data to send back to forge
const encodedData = encodeAbiParameters(
    [
      { name: 'openZeppelinRoot', type: 'bytes32' },
      { name: 'openZeppelinProof', type: 'bytes32[]' },
      { name: 'openZeppelinFlags', type: 'bool[]' }
    ],
    [tree.root as any, proof as any, proofFlags]
)

// write the proof array and flag array to stdout
process.stdout.write(encodedData)